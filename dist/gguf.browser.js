!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("fs"),require("path"),require("os")):"function"==typeof define&&define.amd?define(["fs","path","os"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).GGUF=t(e.require$$0,e.require$$1,e.require$$4)}(this,(function(e,t,n){"use strict";var o="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function r(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var s={GGUFModel:class{constructor({id:e,path:t,metadata:n={},session:o=null,tokenizer:r=null}){this.id=e,this.path=t,this.metadata=n,this.session=o,this.tokenizer=r,this.lastUsed=Date.now(),this.isLoaded=!1,this.metadata.name||(this.metadata.name=e||t.split("/").pop()),this.metadata.createdAt||(this.metadata.createdAt=(new Date).toISOString())}getInfo(){return{id:this.id,name:this.metadata.name,path:this.path,isLoaded:this.isLoaded,lastUsed:this.lastUsed,...this.metadata}}updateLastUsed(){this.lastUsed=Date.now()}unload(){this.session=null,this.isLoaded=!1}},GenerationOptions:class{constructor({maxTokens:e=100,temperature:t=.7,topP:n=.9,topK:o=40,repetitionPenalty:r=1.1,seed:s,stopSequences:i=[]}={}){this.maxTokens=e,this.temperature=t,this.topP=n,this.topK=o,this.repetitionPenalty=r,this.seed=s,this.stopSequences=i}},ModelContext:class{constructor({tokens:e=[],contextSize:t=2048}={}){this.tokens=e,this.contextSize=t,this.outputTokens=[]}addTokens(e){this.tokens=[...this.tokens,...e],this.tokens.length>this.contextSize&&(this.tokens=this.tokens.slice(-this.contextSize))}addOutputToken(e){this.outputTokens.push(e)}getContextLength(){return this.tokens.length}getRemainingSpace(){return this.contextSize-this.tokens.length}clear(){this.tokens=[],this.outputTokens=[]}},createModelId:function(e){const t=e.split("/").pop().split(".")[0];let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return`${t}-${Math.abs(n).toString(16).substring(0,8)}`}};const i={NONE:0,ERROR:1,WARN:2,INFO:3,DEBUG:4};let a={level:"production"===process.env.NODE_ENV?i.INFO:i.DEBUG,prefix:"GGUF.js",useColors:!0,timestamp:!0,showInConsole:!0};const c={reset:"[0m",black:"[30m",red:"[31m",green:"[32m",yellow:"[33m",blue:"[34m",magenta:"[35m",cyan:"[36m",white:"[37m",error:"[31m",warn:"[33m",info:"[36m",debug:"[90m",prefix:"[35m"},l=[];function d(e,t,n){if(i[e.toUpperCase()]>a.level)return;const o=function(e,t){const n=[];if(a.timestamp){const e=(new Date).toISOString();a.useColors?n.push(`${c.debug}[${e}]${c.reset}`):n.push(`[${e}]`)}return a.prefix&&(a.useColors?n.push(`${c.prefix}[${a.prefix}]${c.reset}`):n.push(`[${a.prefix}]`)),a.useColors?n.push(`${c[e.toLowerCase()]}[${e}]${c.reset}`):n.push(`[${e}]`),n.push(t),n.join(" ")}(e,t),r={level:e,message:t,data:n,timestamp:new Date,formatted:o};if(l.push(r),l.length>1e3&&l.shift(),a.showInConsole){const t=e.toLowerCase();console[t]?void 0!==n?console[t](o,n):console[t](o):console.log(o)}return r}function f(e,t){let n;return n=t instanceof Error?{name:t.name,message:t.message,stack:t.stack}:t,d("ERROR",e,n)}function u(e,t){return d("WARN",e,t)}function h(e,t){return d("INFO",e,t)}function m(e,t){return d("DEBUG",e,t)}var p={configure:function(e={}){if(void 0!==e.level)if("string"==typeof e.level){const t=e.level.toUpperCase();void 0!==i[t]&&(a.level=i[t])}else"number"==typeof e.level&&(a.level=e.level);void 0!==e.prefix&&(a.prefix=e.prefix),void 0!==e.useColors&&(a.useColors=!!e.useColors),void 0!==e.timestamp&&(a.timestamp=!!e.timestamp),void 0!==e.showInConsole&&(a.showInConsole=!!e.showInConsole)},error:f,warn:u,info:h,debug:m,getLogs:function(){return[...l]},clearLogs:function(){l.length=0},createLogger:function(e){return{error:(t,n)=>f(`[${e}] ${t}`,n),warn:(t,n)=>u(`[${e}] ${t}`,n),info:(t,n)=>h(`[${e}] ${t}`,n),debug:(t,n)=>m(`[${e}] ${t}`,n)}},LOG_LEVELS:i};const{GGUFModel:w,createModelId:g}=s,y=p,k=new Map;var M={loadModel:async function(e,t={},n){if(!n)throw new Error("No adapter provided. Please use an environment-specific loader.");const{useCache:o=!0,quantization:r="q4_0",contextSize:s=2048,lowMemory:i=!1,modelId:a,metadata:c={}}=t,l=a||g(e);if(o&&k.has(l)){y.info(`Using cached model: ${l}`);const e=k.get(l);return e.updateLastUsed(),e}y.info(`Loading model from: ${e}`),y.debug("Loading options:",{quantization:r,contextSize:s,lowMemory:i});try{const t=new w({id:l,path:e,metadata:{...c,quantization:r,contextSize:s,lowMemory:i}}),{session:a,tokenizer:d}=await n.initializeModel(e,{quantization:r,contextSize:s,lowMemory:i});return t.session=a,t.tokenizer=d,t.isLoaded=!0,o&&k.set(l,t),y.info(`Model loaded successfully: ${l}`),t}catch(e){throw y.error(`Failed to load model: ${e.message}`),new Error(`Failed to load GGUF model: ${e.message}`)}},unloadModel:function(e,t){if(k.has(e)){const n=k.get(e);return t&&t.freeModel&&t.freeModel(n),n.unload(),k.delete(e),y.info(`Model unloaded: ${e}`),!0}return y.warn(`Model not found for unloading: ${e}`),!1},getModel:function(e){if(k.has(e)){const t=k.get(e);return t.updateLastUsed(),t}return null},listModels:function(){return Array.from(k.values()).map((e=>e.getInfo())).sort(((e,t)=>t.lastUsed-e.lastUsed))},clearModels:function(e){for(const[t,n]of k.entries())e&&e.freeModel&&e.freeModel(n),n.unload();k.clear(),y.info("All models unloaded from memory")}};const{ModelContext:b,GenerationOptions:$}=s,z=p,S=new Map;var v={generate:async function(e,t,n={},o){if(!o)throw new Error("No adapter provided. Please use an environment-specific inference engine.");if(!e||!e.isLoaded||!e.session)throw new Error("Model not loaded properly");S.set(e.id,!1);const r=new $(n);z.info(`Generating with model: ${e.id}`),z.debug("Prompt:",t.substring(0,100)+(t.length>100?"...":"")),z.debug("Options:",r);try{const n=await o.tokenize(e,t);z.debug(`Tokenized prompt: ${n.length} tokens`);const s=new b({tokens:n,contextSize:e.metadata.contextSize||2048});s.getContextLength()>=s.contextSize&&(z.warn(`Prompt exceeds context size: ${s.getContextLength()} tokens`),s.tokens=s.tokens.slice(100-s.contextSize));const i=Math.min(r.maxTokens,s.getRemainingSpace()-10),a=await o.runInference(e,s,{...r,maxTokens:i},(()=>S.get(e.id))),c=await o.detokenize(e,a);return z.info(`Generated ${a.length} tokens`),c}catch(t){if(S.get(e.id))return z.info("Generation was cancelled"),"";throw z.error(`Generation failed: ${t.message}`),new Error(`Text generation failed: ${t.message}`)}finally{e.updateLastUsed()}},streamGenerate:async function(e,t,n,o={},r){if(!r)throw new Error("No adapter provided. Please use an environment-specific inference engine.");if(!e||!e.isLoaded||!e.session)throw new Error("Model not loaded properly");S.set(e.id,!1);const s=new $(o);z.info(`Streaming with model: ${e.id}`),z.debug("Prompt:",t.substring(0,100)+(t.length>100?"...":""));try{const o=await r.tokenize(e,t),i=new b({tokens:o,contextSize:e.metadata.contextSize||2048});i.getContextLength()>=i.contextSize&&(z.warn(`Prompt exceeds context size: ${i.getContextLength()} tokens`),i.tokens=i.tokens.slice(100-i.contextSize));const a=Math.min(s.maxTokens,i.getRemainingSpace()-10),c=async t=>{try{const o=await r.detokenizeToken(e,t);n(o,!1)}catch(e){z.error(`Token callback error: ${e.message}`)}};await r.runInferenceStreaming(e,i,c,{...s,maxTokens:a},(()=>S.get(e.id))),n("",!0),z.info("Streaming generation complete")}catch(t){if(S.get(e.id))return z.info("Streaming was cancelled"),void n("",!0);throw z.error(`Streaming failed: ${t.message}`),n("",!0),new Error(`Streaming text generation failed: ${t.message}`)}finally{e.updateLastUsed()}},cancelGeneration:function(e){const t="string"==typeof e?e:e.id;return t?(z.info(`Cancelling generation for model: ${t}`),S.set(t,!0),!0):(z.warn("No model ID provided for cancellation"),!1)}};const x=p;class E{encode(e){throw new Error("encode() method must be implemented by subclass")}decode(e){throw new Error("decode() method must be implemented by subclass")}decodeToken(e){return this.decode([e])}}class F extends E{constructor(){super(),this.encoder=new Map,this.decoder=new Map;for(let e=0;e<128;e++){const t=String.fromCharCode(e);this.encoder.set(t,e),this.decoder.set(e,t)}this.specialTokens={BOS:128,EOS:129,PAD:130,UNK:131},Object.entries(this.specialTokens).forEach((([e,t])=>{this.decoder.set(t,`<${e}>`)}))}encode(e){return Array.from(e).map((e=>this.encoder.has(e)?this.encoder.get(e):this.specialTokens.UNK))}decode(e){return e.map((e=>this.decoder.has(e)?this.decoder.get(e):"")).join("")}}class T extends E{constructor(e){super(),this.vocab=new Map(Object.entries(e.vocab||{}).map((([e,t])=>[e,Number(t)]))),this.decoder=new Map(Array.from(this.vocab.entries()).map((([e,t])=>[t,e]))),this.merges=e.merges||[],this.specialTokens=e.specialTokens||{},this.mergePatterns=new Map,this.buildMergePatterns()}buildMergePatterns(){this.merges.forEach(((e,t)=>{const[n,o]=e,r=new RegExp(`(?<=^|\\s)(${n})(${o})(?=\\s|$)`,"g");this.mergePatterns.set(t,{pattern:r,replacement:`${n}${o}`})}))}encode(e){return e?e.split(/(\s+)/).flatMap((e=>{if(!e.trim()){return[this.vocab.get(e)||this.vocab.get("<UNK>")||0]}let t=Array.from(e).map((e=>e));for(let e=0;e<this.merges.length;e++){const[n,o]=this.merges[e];let r=0;for(;r<t.length-1;)t[r]===n&&t[r+1]===o?t=[...t.slice(0,r),n+o,...t.slice(r+2)]:r++}return t.map((e=>this.vocab.has(e)?this.vocab.get(e):this.vocab.get("<UNK>")||0))})):[]}decode(e){return e.map((e=>this.decoder.has(e)?this.decoder.get(e):"")).join("")}}function A(e){return e?"bpe"===e.tokenizer_type||e.merges?(x.info("Creating BPE tokenizer"),new T(e)):(x.warn("Unknown tokenizer type, using fallback character tokenizer"),new F):(x.warn("No tokenizer configuration provided, using fallback character tokenizer"),new F)}var G={BaseTokenizer:E,CharacterTokenizer:F,BPETokenizer:T,createTokenizer:A,loadTokenizerFromFile:async function(e,t){try{if(!t||!t.readFile)throw new Error("Environment adapter does not support file reading");const n=await t.readFile(e);return A(JSON.parse(n))}catch(t){return x.error(`Failed to load tokenizer from ${e}: ${t.message}`),new F}},extractTokenizerFromModel:async function(e,t){try{if(!t||!t.extractTokenizer)throw new Error("Environment adapter does not support tokenizer extraction");return A(await t.extractTokenizer(e))}catch(e){return x.error(`Failed to extract tokenizer from model: ${e.message}`),new F}}};const U=e,I=t,C=p;let P;try{const e=require("node-llama-cpp");P=e.LlamaModel}catch(f){C.warn("node-llama-cpp not found. Install it with: npm install node-llama-cpp"),P=null}var L={initializeModel:async function(e,t={}){if(!P)throw new Error("node-llama-cpp is required but not installed");if(!U.existsSync(e))throw new Error(`Model file not found: ${e}`);C.info(`Initializing GGUF model from: ${e}`);const{contextSize:o=2048,quantization:r="q4_0",lowMemory:s=!1,seed:i=Math.floor(4294967295*Math.random()),threads:a=Math.max(1,n.cpus().length/2)}=t,c=I.resolve(e);try{const e=new P({modelPath:c,contextSize:o,seed:i,threads:a,useMlock:!s,batchSize:512,gpuLayers:0}),t={encode:async t=>e.tokenize(t),decode:async t=>e.detokenize(t),decodeToken:async t=>e.detokenize([t])};return C.info(`Model initialized successfully (context size: ${o}, threads: ${a})`),{session:e,tokenizer:t}}catch(e){throw C.error(`Failed to initialize model: ${e.message}`),e}},tokenize:async function(e,t){if(!e.session)throw new Error("Model session not initialized");return e.session.tokenize(t)},detokenize:async function(e,t){if(!e.session)throw new Error("Model session not initialized");return e.session.detokenize(t)},detokenizeToken:async function(e,t){if(!e.session)throw new Error("Model session not initialized");return e.session.detokenize([t])},runInference:async function(e,t,n,o){if(!e.session)throw new Error("Model session not initialized");const r={nPredict:n.maxTokens,temperature:n.temperature,topP:n.topP,topK:n.topK,repeatPenalty:n.repetitionPenalty,seed:n.seed,stop:n.stopSequences||[]};return new Promise(((n,s)=>{try{const s=e.session.generate({tokens:t.tokens,...r}),i=[];for(const e of s){if(o&&o()){C.info("Generation cancelled");break}if(i.push(e),i.length>=r.nPredict)break}n(i)}catch(e){s(e)}}))},runInferenceStreaming:async function(e,t,n,o,r){if(!e.session)throw new Error("Model session not initialized");const s={nPredict:o.maxTokens,temperature:o.temperature,topP:o.topP,topK:o.topK,repeatPenalty:o.repetitionPenalty,seed:o.seed,stop:o.stopSequences||[]};return new Promise(((o,i)=>{try{const i=e.session.generate({tokens:t.tokens,...s});let a=0;for(const e of i){if(r&&r()){C.info("Streaming generation cancelled");break}if(n(e),a++,a>=s.nPredict)break}o()}catch(e){i(e)}}))},freeModel:function(e){e.session&&"function"==typeof e.session.dispose&&(e.session.dispose(),C.info(`Model resources freed: ${e.id}`))},discoverModels:async function(e){if(!U.existsSync(e))return C.warn(`Model directory not found: ${e}`),[];C.info(`Searching for GGUF models in: ${e}`);try{const t=U.readdirSync(e),n=t.filter((e=>e.toLowerCase().endsWith(".gguf"))).map((t=>{const n=I.join(e,t),o=U.statSync(n),r=I.basename(t,".gguf"),s=r.split(".");return{id:r,name:s[0],path:n,quantization:s.length>1?s[1]:"unknown",size:o.size,createdAt:o.birthtime.toISOString()}}));return C.info(`Found ${n.length} GGUF models`),n}catch(e){return C.error(`Error discovering models: ${e.message}`),[]}}};const B=p,O="object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate;let D=null,N=null,R=!1;async function q(e={}){if(R)return!0;if(!O)return B.error("WebAssembly is not supported in this browser"),!1;const t=e.wasmUrl||"https://cdn.jsdelivr.net/npm/gguf.js/dist/wasm/gguf-web.wasm";try{B.info(`Loading WASM from ${t}`);const e=await fetch(t);if(!e.ok)throw new Error(`Failed to fetch WASM: ${e.statusText}`);const n=await e.arrayBuffer();D=await WebAssembly.compile(n);const o=new WebAssembly.Memory({initial:256,maximum:2048}),r={env:{memory:o,consoleLog:(e,t)=>{const n=new Uint8Array(o.buffer,e,t),r=(new TextDecoder).decode(n);console.log(`[WASM] ${r}`)},consoleError:(e,t)=>{const n=new Uint8Array(o.buffer,e,t),r=(new TextDecoder).decode(n);console.error(`[WASM] ${r}`)}}};return N=await WebAssembly.instantiate(D,r),R=!0,B.info("WASM initialized successfully"),!0}catch(e){return B.error(`Failed to initialize WASM: ${e.message}`),!1}}async function H(e,t){if(!e.tokenizer)throw new Error("Model tokenizer not initialized");return e.tokenizer.decodeToken(t)}var j={initializeWasm:q,initializeModel:async function(e,t={}){if(!R){if(!await q(t))throw new Error("WebAssembly initialization failed")}let n;if("string"==typeof e){B.info(`Fetching model from ${e}`);try{const t=await fetch(e);if(!t.ok)throw new Error(`Failed to fetch model: ${t.statusText}`);n=await t.arrayBuffer(),B.info(`Model fetched: ${n.byteLength} bytes`)}catch(e){throw new Error(`Failed to fetch model: ${e.message}`)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Model must be a URL string or ArrayBuffer");n=e,B.info(`Using provided model data: ${n.byteLength} bytes`)}try{const e=new Uint8Array(n),o=N.exports,r=o.allocateMemory(e.length),s=o.memory,i=new Uint8Array(s.buffer);i.set(e,r);const a=o.loadModel(r,e.length,t.contextSize||2048);if(a<0)throw new Error(`Failed to load model: error code ${a}`);B.info(`Model loaded with ID: ${a}`);return{session:{modelId:a},tokenizer:{encode:async e=>{const t=(new TextEncoder).encode(e),n=o.allocateMemory(t.length);i.set(t,n);const r=o.tokenize(a,n,t.length),c=new DataView(s.buffer),l=c.getInt32(r,!0),d=c.getInt32(r+4,!0),f=[];for(let e=0;e<l;e++)f.push(c.getInt32(d+4*e,!0));return o.freeMemory(n),o.freeMemory(r),f},decode:async e=>{const t=o.allocateMemory(4*e.length),n=new Int32Array(s.buffer,t,e.length);e.forEach(((e,t)=>n[t]=e));const r=o.detokenize(a,t,e.length),i=new DataView(s.buffer),c=i.getInt32(r,!0),l=i.getInt32(r+4,!0),d=new Uint8Array(s.buffer,l,c),f=(new TextDecoder).decode(d);return o.freeMemory(t),o.freeMemory(r),f},decodeToken:async e=>{const t=o.allocateMemory(4);new Int32Array(s.buffer,t,1)[0]=e;const n=o.detokenize(a,t,1),r=new DataView(s.buffer),i=r.getInt32(n,!0),c=r.getInt32(n+4,!0),l=new Uint8Array(s.buffer,c,i),d=(new TextDecoder).decode(l);return o.freeMemory(t),o.freeMemory(n),d}}}}catch(e){throw B.error(`Failed to initialize model: ${e.message}`),e}},tokenize:async function(e,t){if(!e.tokenizer)throw new Error("Model tokenizer not initialized");return e.tokenizer.encode(t)},detokenize:async function(e,t){if(!e.tokenizer)throw new Error("Model tokenizer not initialized");return e.tokenizer.decode(t)},detokenizeToken:H,runInference:async function(e,t,n,o){if(!R||!N)throw new Error("WASM not initialized");const r=N.exports,{modelId:s}=e.session;try{const e=t.tokens,i=r.allocateMemory(4*e.length),a=new Int32Array(r.memory.buffer,i,e.length);e.forEach(((e,t)=>a[t]=e));const c=r.allocateMemory(40),l=new DataView(r.memory.buffer,c);let d=0;l.setInt32(d,n.maxTokens||100,!0),d+=4,l.setFloat32(d,n.temperature||.7,!0),d+=4,l.setFloat32(d,n.topP||.9,!0),d+=4,l.setInt32(d,n.topK||40,!0),d+=4,l.setFloat32(d,n.repetitionPenalty||1.1,!0),d+=4,l.setInt32(d,n.seed||Math.floor(4294967295*Math.random()),!0);const f=r.generateText(s,i,e.length,c),u=()=>!(!o||!o())&&(r.cancelGeneration(s),!0);let h=!1;const m=[];for(;!h&&!u();){const e=r.getGenerationStatus(s);if(0!==e){if(1!==e)throw r.freeMemory(i),r.freeMemory(c),new Error(`Generation failed with status code ${e}`);{h=!0;const e=new DataView(r.memory.buffer),t=e.getInt32(f,!0),n=e.getInt32(f+4,!0),o=new Int32Array(r.memory.buffer,n,t);for(let e=0;e<t;e++)m.push(o[e]);r.freeMemory(i),r.freeMemory(c),r.freeMemory(f)}}else await new Promise((e=>setTimeout(e,10)))}return m}catch(e){throw B.error(`Inference error: ${e.message}`),e}},runInferenceStreaming:async function(e,t,n,o,r){if(!R||!N)throw new Error("WASM not initialized");const s=N.exports,{modelId:i}=e.session;try{const a=t.tokens,c=s.allocateMemory(4*a.length),l=new Int32Array(s.memory.buffer,c,a.length);a.forEach(((e,t)=>l[t]=e));const d=s.allocateMemory(40),f=new DataView(s.memory.buffer,d);let u=0;for(f.setInt32(u,o.maxTokens||100,!0),u+=4,f.setFloat32(u,o.temperature||.7,!0),u+=4,f.setFloat32(u,o.topP||.9,!0),u+=4,f.setInt32(u,o.topK||40,!0),u+=4,f.setFloat32(u,o.repetitionPenalty||1.1,!0),u+=4,f.setInt32(u,o.seed||Math.floor(4294967295*Math.random()),!0),u+=4,f.setInt32(u,1,!0),s.startStreamingGeneration(i,c,a.length,d);;){if(r&&r()){s.cancelGeneration(i);break}const t=s.getNextToken(i);if(0!==t){if(-1===t)break;{const o=new DataView(s.memory.buffer).getInt32(t,!0);await H(e,o);await n(o),s.freeMemory(t)}}else await new Promise((e=>setTimeout(e,10)))}s.freeMemory(c),s.freeMemory(d)}catch(e){throw B.error(`Streaming inference error: ${e.message}`),e}},freeModel:function(e){if(R&&N&&e.session)try{const{modelId:t}=e.session;N.exports.freeModel(t),B.info(`Model resources freed: ${t}`)}catch(e){B.error(`Error freeing model: ${e.message}`)}}};const W="undefined"!=typeof window&&(void 0!==window.React||(()=>{try{return require("react"),!0}catch{return!1}})());let J;if(W)try{J="undefined"!=typeof window&&window.React?window.React:require("react")}catch(f){console.warn("React not found, hooks will not function properly")}const K=M,_=v,V=p;function Y(e){if(J&&J.useState)return J.useState(e);{let t=e;const n=e=>{t="function"==typeof e?e(t):e};return[t,n]}}function Z(e,t){if(J&&J.useEffect)return J.useEffect(e,t);return e()}function Q(e,t){return J&&J.useCallback?J.useCallback(e,t):e}function X(e){return J&&J.useRef?J.useRef(e):{current:e}}function ee(e,t={}){const[n,o]=Y(null),[r,s]=Y(!1),[i,a]=Y(null),c=Q((async(t,n={})=>{s(!0),a(null);try{const r=await K.loadModel(t,n,e);return o(r),r}catch(e){const t=e instanceof Error?e.message:String(e);throw a(t),e}finally{s(!1)}}),[e]),l=Q((async()=>{if(n)try{return await K.unloadModel(n.id,e),o(null),!0}catch(e){const t=e instanceof Error?e.message:String(e);throw a(t),e}return!1}),[n,e]),d=Q((async t=>{if(!e.discoverModels)return a("Model discovery not supported in this environment"),[];try{return await e.discoverModels(t)}catch(e){const t=e instanceof Error?e.message:String(e);throw a(t),e}}),[e]);return Z((()=>()=>{if(n&&n.id)try{K.unloadModel(n.id,e)}catch(e){V.warn(`Failed to unload model on unmount: ${e.message}`)}}),[n,e]),{model:n,isLoading:r,error:i,loadModel:c,unloadModel:l,discoverModels:d}}function te(e,t={}){const[n,o]=Y(!1),[r,s]=Y(null),[i,a]=Y(""),c=X(!1),l=Q((async(t,n,r={})=>{if(!t||!t.isLoaded){const e=new Error("Model not loaded properly");throw s(e.message),e}o(!0),s(null),a(""),c.current=!1;try{const o=await _.generate(t,n,r,e,(()=>c.current));return a(o),o}catch(e){if(!c.current){const t=e instanceof Error?e.message:String(e);throw s(t),e}return""}finally{o(!1)}}),[e]),d=Q((async(t,n,r,i={})=>{if(!t||!t.isLoaded){const e=new Error("Model not loaded properly");throw s(e.message),e}o(!0),s(null),a(""),c.current=!1;let l="";const d=(e,t)=>{c.current||(l+=e,a(l),r(e,t))};try{return await _.streamGenerate(t,n,d,i,e,(()=>c.current)),l}catch(e){if(!c.current){const t=e instanceof Error?e.message:String(e);throw s(t),e}return l}finally{o(!1)}}),[e]);return{isGenerating:n,error:r,output:i,generate:l,streamGenerate:d,cancelGeneration:Q((()=>(c.current=!0,o(!1),!0)),[])}}var ne={useModel:ee,useGeneration:te,useChat:function(e,t={}){const[n,o]=Y([]),[r,s]=Y(!1),[i,a]=Y(null),c=Q((e=>{const t={id:Date.now(),role:"user",content:e,timestamp:(new Date).toISOString()};return o((e=>[...e,t])),t}),[]),l=Q((e=>{const t={id:Date.now(),role:"assistant",content:e,timestamp:(new Date).toISOString()};return o((e=>[...e,t])),t}),[]),d=Q((e=>{let t="";e&&(t+=`System: ${e}\n\n`);for(const e of n)"user"===e.role?t+=`User: ${e.content}\n\n`:"assistant"===e.role?t+=`Assistant: ${e.content}\n\n`:"system"===e.role&&(t+=`System: ${e.content}\n\n`);return t+="Assistant: ",t}),[n]),f=Q((async(t,n="",o={})=>{if(!t||!t.isLoaded){const e=new Error("Model not loaded properly");throw a(e.message),e}s(!0),a(null);try{const r=d(n),s=await _.generate(t,r,o,e);return l(s),s}catch(e){const t=e instanceof Error?e.message:String(e);throw a(t),e}finally{s(!1)}}),[d,l,e]),u=Q((async(t,n,r="",i={})=>{if(!t||!t.isLoaded){const e=new Error("Model not loaded properly");throw a(e.message),e}s(!0),a(null);const c={id:Date.now(),role:"assistant",content:"",timestamp:(new Date).toISOString()};o((e=>[...e,c]));let l="";const f=(e,t)=>{t?n("",!0):(l+=e,o((e=>{const t=[...e],n=t.length-1;return n>=0&&t[n].id===c.id&&(t[n]={...t[n],content:l}),t})),n(e,t))};try{const n=d(r);return await _.streamGenerate(t,n,f,i,e),l}catch(e){const t=e instanceof Error?e.message:String(e);throw a(t),e}finally{s(!1)}}),[d,e]),h=Q((()=>{o([])}),[]);return{messages:n,isGenerating:r,error:i,addUserMessage:c,addAssistantMessage:l,generateResponse:f,streamResponse:u,clearMessages:h,formatPrompt:d}},createGGUFContext:W?function(e){if(!J)throw new Error("React is required to create a context provider");const t=J.createContext(null),n=J.createContext(null);return{GGUFProvider:({children:o,initialOptions:r={}})=>{const s=ee(e,r),i=te(e,r);return J.createElement(t.Provider,{value:s},J.createElement(n.Provider,{value:i},o))},useGGUFModel:()=>{const e=J.useContext(t);if(!e)throw new Error("useGGUFModel must be used within a GGUFProvider");return e},useGGUFGeneration:()=>{const e=J.useContext(n);if(!e)throw new Error("useGGUFGeneration must be used within a GGUFProvider");return e}}}:void 0,_react:{useState:Y,useEffect:Z,useCallback:Q,useRef:X}};const oe=p;class re{constructor(){this.allocations=new Map,this.counter=0,this.stats={allocated:0,freed:0,active:0,peak:0,allocations:0,frees:0},"undefined"!=typeof window&&window.performance&&"memory"in window.performance?this.hasBrowserMemoryStats=!0:this.hasBrowserMemoryStats=!1,"undefined"!=typeof process&&process.memoryUsage?this.hasNodeMemoryStats=!0:this.hasNodeMemoryStats=!1}allocate(e,{type:t,description:n}={}){const o="alloc_"+ ++this.counter,r={id:o,size:e,type:t||"unknown",timestamp:Date.now(),description:n||""};return this.allocations.set(o,r),this.stats.allocated+=e,this.stats.active+=e,this.stats.allocations++,this.stats.active>this.stats.peak&&(this.stats.peak=this.stats.active),oe.debug(`Memory allocated: ${se(e)} (${t||"unknown"})${n?` - ${n}`:""}`),o}free(e){const t=this.allocations.get(e);return t?(this.stats.freed+=t.size,this.stats.active-=t.size,this.stats.frees++,this.allocations.delete(e),oe.debug(`Memory freed: ${se(t.size)} (${t.type})${t.description?` - ${t.description}`:""}`),!0):(oe.warn(`Attempted to free unknown allocation: ${e}`),!1)}freeAll(){const e=this.allocations.size;if(0===e)return 0;oe.info(`Freeing all ${e} memory allocations (${se(this.stats.active)})`);const t=Array.from(this.allocations.keys());for(const e of t)this.free(e);return e}freeByType(e){let t=0;const n=Array.from(this.allocations.values()).filter((t=>t.type===e));oe.info(`Freeing ${n.length} '${e}' allocations`);for(const e of n)this.free(e.id)&&t++;return t}getStats(){const e={...this.stats,allocatedFormatted:se(this.stats.allocated),freedFormatted:se(this.stats.freed),activeFormatted:se(this.stats.active),peakFormatted:se(this.stats.peak),activeAllocations:this.allocations.size};if(this.hasBrowserMemoryStats){const t=window.performance.memory;e.browser={totalJSHeapSize:t.totalJSHeapSize,usedJSHeapSize:t.usedJSHeapSize,jsHeapSizeLimit:t.jsHeapSizeLimit,totalJSHeapSizeFormatted:se(t.totalJSHeapSize),usedJSHeapSizeFormatted:se(t.usedJSHeapSize),jsHeapSizeLimitFormatted:se(t.jsHeapSizeLimit)}}if(this.hasNodeMemoryStats){const t=process.memoryUsage();e.node={rss:t.rss,heapTotal:t.heapTotal,heapUsed:t.heapUsed,external:t.external,arrayBuffers:t.arrayBuffers,rssFormatted:se(t.rss),heapTotalFormatted:se(t.heapTotal),heapUsedFormatted:se(t.heapUsed),externalFormatted:se(t.external),arrayBuffersFormatted:se(t.arrayBuffers)}}return e}getAllocations(){return Array.from(this.allocations.values())}getAllocationsByType(){const e={};for(const t of this.allocations.values()){const n=t.type||"unknown";e[n]||(e[n]={count:0,size:0,allocations:[]}),e[n].count++,e[n].size+=t.size,e[n].allocations.push(t)}for(const t in e)e[t].sizeFormatted=se(e[t].size);return e}logMemoryUsage(e=!1){const t=this.getStats();if(oe.info("Memory Usage Summary:"),oe.info(`  Total Allocated: ${t.allocatedFormatted}`),oe.info(`  Total Freed: ${t.freedFormatted}`),oe.info(`  Active: ${t.activeFormatted}`),oe.info(`  Peak: ${t.peakFormatted}`),oe.info(`  Allocations: ${t.allocations}`),oe.info(`  Frees: ${t.frees}`),oe.info(`  Active Allocations: ${t.activeAllocations}`),t.browser&&(oe.info("Browser Memory:"),oe.info(`  Used JS Heap: ${t.browser.usedJSHeapSizeFormatted}`),oe.info(`  Total JS Heap: ${t.browser.totalJSHeapSizeFormatted}`),oe.info(`  JS Heap Limit: ${t.browser.jsHeapSizeLimitFormatted}`)),t.node&&(oe.info("Node.js Memory:"),oe.info(`  RSS: ${t.node.rssFormatted}`),oe.info(`  Heap Total: ${t.node.heapTotalFormatted}`),oe.info(`  Heap Used: ${t.node.heapUsedFormatted}`),oe.info(`  External: ${t.node.externalFormatted}`),oe.info(`  Array Buffers: ${t.node.arrayBuffersFormatted}`)),e){const t=this.getAllocationsByType();oe.info("Allocations by Type:");for(const e in t)oe.info(`  ${e}: ${t[e].count} allocations, ${t[e].sizeFormatted}`);if("full"===e){oe.info("All Allocations:");for(const e of this.allocations.values())oe.info(`  ${e.id}: ${se(e.size)} (${e.type})${e.description?` - ${e.description}`:""}`)}}}resetStats(){const e=this.stats.allocated-this.stats.freed;this.stats={allocated:e,freed:0,active:e,peak:e,allocations:this.allocations.size,frees:0},oe.debug("Memory stats reset")}}function se(e,t=2){if(0===e)return"0 Bytes";const n=t<0?0:t,o=Math.floor(Math.log(e)/Math.log(1024));return`${parseFloat((e/Math.pow(1024,o)).toFixed(n))} ${["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][o]}`}const ie=new re;var ae={MemoryManager:re,formatBytes:se,withMemoryTracking:function(e,t={}){const n=t.memoryManager||ie,o=t.type||"function",r=t.description||e.name||"anonymous function";return async function(...t){const s=n.getStats(),i=n.allocate(0,{type:o,description:`Function call: ${r}`});try{const a=await e.apply(this,t),c=n.getStats().active-s.active;return n.free(i),n.allocate(c,{type:o,description:`Result of: ${r}`}),a}catch(e){throw n.free(i),e}}},triggerGC:function(){return void 0!==o&&o.gc?(o.gc(),oe.debug("Triggered Node.js garbage collection"),!0):"undefined"!=typeof window&&window.gc?(window.gc(),oe.debug("Triggered browser garbage collection"),!0):(oe.debug("Cannot trigger garbage collection (not available in this environment)"),!1)},createMemoryPool:function(e){const t="undefined"!=typeof ArrayBuffer?new ArrayBuffer(e):Buffer.alloc(e),n=[];let o=0;return{allocate(r){if(o+r>e)throw new Error(`Memory pool out of space (${se(r)} requested, ${se(e-o)} available)`);const s=o;o+=r;const i={start:s,size:r,view:"undefined"!=typeof Uint8Array?new Uint8Array(t,s,r):Buffer.from(t,s,r)};return n.push(i),i},free(e){const t=n.indexOf(e);return-1!==t&&(n.splice(t,1),!0)},reset(){n.length=0,o=0},getInfo:()=>({totalSize:e,used:o,free:e-o,allocations:n.length,usedFormatted:se(o),freeFormatted:se(e-o),totalFormatted:se(e)})}},globalMemoryManager:ie};const ce=p;class le{constructor(e={}){this.buffer=[],this.bufferSize=e.bufferSize||1024,this.autoFlush=!1!==e.autoFlush,this.isEnded=!1,this.consumers=[],this.doneCallbacks=[]}write(e){return this.isEnded?(ce.warn("Attempted to write to a closed token stream"),!1):(this.buffer.push(e),this._notifyConsumers(),this.autoFlush&&this.buffer.length>=this.bufferSize&&this.flush(),!0)}writeMany(e){return this.isEnded?(ce.warn("Attempted to write to a closed token stream"),!1):(this.buffer.push(...e),this._notifyConsumers(),this.autoFlush&&this.buffer.length>=this.bufferSize&&this.flush(),!0)}end(){if(!this.isEnded){this.isEnded=!0,this._notifyConsumers();for(const e of this.doneCallbacks)try{e()}catch(e){ce.error("Error in stream done callback",e)}this.doneCallbacks=[]}}flush(){this.buffer=[]}subscribe(e,t){const n={onToken:e};if(this.consumers.push(n),t&&this.doneCallbacks.push(t),this.buffer.length>0)for(const t of this.buffer)try{e(t,!1)}catch(e){ce.error("Error in token consumer",e)}if(this.isEnded&&t)try{t()}catch(e){ce.error("Error in stream done callback",e)}return()=>{this.consumers=this.consumers.filter((e=>e!==n)),this.doneCallbacks=this.doneCallbacks.filter((e=>e!==t))}}read(){return[...this.buffer]}_notifyConsumers(){if(0!==this.consumers.length){for(;this.buffer.length>0;){const e=this.buffer.shift();for(const t of this.consumers)try{t.onToken(e,!1)}catch(e){ce.error("Error in token consumer",e)}}if(this.isEnded){for(const e of this.consumers)try{e.onToken(null,!0)}catch(e){ce.error("Error in token consumer",e)}this.consumers=[]}}}isDone(){return this.isEnded}bufferedTokens(){return this.buffer.length}}async function de(e,t){if("function"!=typeof fetch)throw new Error("Fetch API not available in this environment");const n=await fetch(e);if(!n.ok)throw new Error(`HTTP error ${n.status}: ${n.statusText}`);const o=parseInt(n.headers.get("Content-Length")||"0",10);if(!n.body||!o)return n.arrayBuffer();const r=n.body.getReader();let s=0;const i=[];for(;;){const{done:e,value:n}=await r.read();if(e)break;if(i.push(n),s+=n.length,t){t(s,o,o?Math.round(s/o*100):0)}}const a=new Uint8Array(s);let c=0;for(const e of i)a.set(e,c),c+=e.length;return a.buffer}var fe={TokenStream:le,createTokenStream:function(e,t={}){const n=new le;if(!e||0===e.length)return n.end(),n;const o=t.delay||0,r=t.jitter||!1,s=t.maxJitter||10;let i=0;return o>0?setTimeout((function t(){if(i>=e.length)n.end();else if(n.write(e[i++]),i<e.length){let e=o;r&&(e+=Math.random()*s*2-s,e=Math.max(0,e)),setTimeout(t,e)}else n.end()}),0):(n.writeMany(e),n.end()),n},collectStream:function(e,t=null){return new Promise(((n,o)=>{const r=[];e.subscribe(((e,o)=>{if(null!==e&&(r.push(e),t))try{t(r.length,e)}catch(e){}o&&n(r)}),(()=>n(r)))}))},streamToString:function(e,t=String,n=null){let o="";return new Promise(((r,s)=>{e.subscribe(((e,s)=>{if(null!==e){const r=t(e);if(o+=r,n)try{n(o.length,r)}catch(e){}}s&&r(o)}),(()=>r(o)))}))},fetchWithProgress:de,createChunkedLoader:function(e,t=10485760,n){let o=0,r=0,s=!1;async function i(){try{const t=await fetch(e,{method:"HEAD"});if(!t.ok)throw new Error(`Failed to initialize: ${t.status} ${t.statusText}`);return o=parseInt(t.headers.get("Content-Length")||"0",10),o}catch(e){throw ce.error("Error initializing chunked loader",e),e}}async function a(t,i){if(s)throw new Error("Loading cancelled");o>0&&i>o&&(i=o);try{const s=await fetch(e,{headers:{Range:`bytes=${t}-${i-1}`}});if(!s.ok&&206!==s.status)throw new Error(`Failed to load chunk: ${s.status} ${s.statusText}`);const a=await s.arrayBuffer();if(r+=a.byteLength,n&&o>0){const e=Math.round(r/o*100);n(r,o,e)}return a}catch(e){if(!s)throw ce.error(`Error loading chunk ${t}-${i}`,e),e;throw new Error("Loading cancelled")}}return{init:i,loadChunk:a,loadAll:async function(){if(0===o&&await i(),0===o)return de(e,n);const r=[];let c=0;for(;c<o;){const e=Math.min(c+t,o),n=await a(c,e);if(r.push(n),c=e,s)throw new Error("Loading cancelled")}const l=new Uint8Array(o);let d=0;for(const e of r)l.set(new Uint8Array(e),d),d+=e.byteLength;return l.buffer},cancel:function(){s=!0},getStatus:function(){return{contentLength:o,loaded:r,cancelled:s,progress:o?r/o:0}}}}};var ue={formatChatPrompt:function(e,t={}){const{systemPrompt:n="",useMarkdown:o=!1,userLabel:r="User",assistantLabel:s="Assistant",systemLabel:i="System"}=t;let a="";n&&(a+=o?`**${i}**: ${n}\n\n`:`${i}: ${n}\n\n`);for(const t of e){let e="";"user"===t.role?e=r:"assistant"===t.role?e=s:"system"===t.role&&(e=i),a+=o?`**${e}**: ${t.content}\n\n`:`${e}: ${t.content}\n\n`}return a+=o?`**${s}**: `:`${s}: `,a},formatCompletionPrompt:function(e,t={}){const{suffix:n="",prefix:o=""}=t;return`${o}${e}${n}`},formatInstructions:function(e,t={}){const{prefix:n="Instructions:",suffix:o="",numbered:r=!1}=t;let s=Array.isArray(e)?e:[e],i=n?`${n}\n`:"";return s.forEach(((e,t)=>{i+=r?`${t+1}. ${e}\n`:`- ${e}\n`})),o&&(i+=`\n${o}`),i},cleanOutput:function(e,t={}){const{trimWhitespace:n=!0,removeExtraNewlines:o=!0,removeSpecialTokens:r=!0}=t;let s=e;return r&&(s=s.replace(/<[^>]+>/g,"")),o&&(s=s.replace(/\n{3,}/g,"\n\n")),n&&(s=s.trim()),s},extractJSON:function(e,t={}){const{extractFromText:n=!0,fixBrokenJson:o=!0}=t;let r=e;if(n){const t=e.match(/```(?:json)?\s*({[\s\S]*?})\s*```/)||e.match(/{[\s\S]*?}/);t&&(r=t[1])}try{return JSON.parse(r)}catch(e){if(!o)return null;try{let e=r.replace(/'/g,'"');return e=e.replace(/([{,]\s*)(\w+)(\s*:)/g,'$1"$2"$3'),e=e.replace(/,\s*}/g,"}").replace(/,\s*]/g,"]"),JSON.parse(e)}catch(e){return null}}},templatePrompt:function(e,t={}){return e.replace(/\{(\w+)\}/g,((e,n)=>void 0!==t[n]?t[n]:e))},truncatePrompt:function(e,t,n,o={}){const{fromStart:r=!0,ellipsis:s="..."}=o;if(n(e)<=t)return e;const i=t-n(s),a=e.split(/\s+/);if(r){let e="",t=0;for(let o=a.length-1;o>=0;o--){const r=a[o],s=n(r);if(!(t+s<=i))break;e=r+(e?" "+e:""),t+=s}return s+" "+e}{let e="",t=0;for(let o=0;o<a.length;o++){const r=a[o],s=n(r);if(!(t+s<=i))break;e+=(e?" ":"")+r,t+=s}return e+" "+s}}};const{GGUFModel:he,GenerationOptions:me,ModelContext:pe,createModelId:we}=s,ge=M,ye=v,ke=G,Me=L,be=j,$e=ne,ze=p,Se=ae,ve=fe,xe=ue,Ee="undefined"==typeof window&&"undefined"!=typeof process&&process.versions&&process.versions.node,Fe="undefined"!=typeof window,Te="undefined"!=typeof window&&void 0!==window.React;function Ae(e){return{loadModel:(t,n)=>ge.loadModel(t,n,e),unloadModel:t=>ge.unloadModel(t,e),getModel:e=>ge.getModel(e),listModels:()=>ge.listModels(),clearModels:()=>ge.clearModels(e),generate:(t,n,o)=>ye.generate(t,n,o,e),streamGenerate:(t,n,o,r)=>ye.streamGenerate(t,n,o,r,e),cancelGeneration:e=>ye.cancelGeneration(e),tokenize:(t,n)=>e.tokenize(t,n),detokenize:(t,n)=>e.detokenize(t,n),...e.discoverModels?{discoverModels:t=>e.discoverModels(t)}:{},...Te?{useModel:t=>$e.useModel(e,t),useGeneration:t=>$e.useGeneration(e,t),useChat:t=>$e.useChat(e,t)}:{}}}return r({...Ae(Ee?Me:Fe?be:(ze.warn("No environment-specific adapter detected, some features may not work properly"),null)),GGUFModel:he,GenerationOptions:me,ModelContext:pe,createModelId:we,createInstance:Ae,adapters:{node:Me,browser:be,react:$e},tokenizer:ke,utils:{logger:ze,memory:Se,streaming:ve,formats:xe},environment:{isNode:Ee,isBrowser:Fe,isReact:Te},version:"0.1.0"})}));
//# sourceMappingURL=gguf.browser.js.map
